<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>G√©n√©rateur de mot de passe s√©curis√©</title>
  <style>
    /* Styles globaux */
    :root {
      --bg-light: #f0f0f0;
      --text-light: #333;
      --bg-dark:  #222;
      --text-dark: #eee;
      --accent:    #4CAF50;
      --strength-weak: #e74c3c;    /* Rouge */
      --strength-medium: #f1c40f;  /* Jaune */
      --strength-strong: #2ecc71;  /* Vert */
      --strength-very-strong: #0a7a3b; /* Vert fonc√© */
    }
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: var(--bg-light);
      color: var(--text-light);
      transition: background-color 0.3s, color 0.3s;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 1rem;
      box-sizing: border-box;
    }
    body.dark {
      background-color: var(--bg-dark);
      color: var(--text-dark);
    }
    .container {
      background: rgba(255,255,255,0.8);
      padding: 2rem;
      border-radius: 1rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      max-width: 450px;
      width: 100%;
    }
    body.dark .container {
      background: rgba(0,0,0,0.6);
    }
    h1 {
      text-align: center;
      margin-bottom: 1rem;
    }
    .controls {
      display: grid;
      gap: 0.75rem;
    }
    .controls label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .controls .char-option {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .controls .char-option .min-input-group {
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }
    .controls .char-option input[type="number"] {
        width: 60px;
        text-align: center;
    }

    select, input[type="text"], input[type="number"] {
      width: 100%;
      padding: 0.5rem;
      font-size: 1rem;
      border-radius: 0.5rem;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }
    body.dark select, 
    body.dark input[type="text"],
    body.dark input[type="number"] {
      background: #444;
      border-color: #555;
      color: var(--text-dark);
    }
    button {
      cursor: pointer;
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.75rem;
      font-size: 1rem;
      border-radius: 0.5rem;
    }
    button:hover {
      opacity: 0.9;
    }
    .password-output-group {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .password-output-group input[type="text"] {
        flex-grow: 1;
    }
    .password-output-group button {
        width: auto;
        padding: 0.5rem 0.75rem;
        background: #6c757d;
    }
    .password-output-group button:hover {
        background: #5a6268;
    }

    .strength {
      text-align: center;
      margin-top: 0.5rem;
      font-weight: bold;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .strength-bar {
      height: 10px;
      border-radius: 5px;
      background-color: #ddd;
      overflow: hidden;
    }
    .strength-indicator {
      height: 100%;
      width: 0%;
      background-color: var(--strength-weak);
      transition: width 0.3s ease-in-out, background-color 0.3s ease-in-out;
    }
    .strength-text {
      color: var(--text-light);
    }
    .error-message {
        color: #e74c3c;
        font-size: 0.85rem;
        text-align: center;
        min-height: 1.2rem;
    }
    .toggle-theme {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 1rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="toggle-theme">
      <button id="themeToggle">Mode sombre</button>
    </div>
    <h1>G√©n√©rateur de mot de passe</h1>
    <div class="controls">
      <label>
        Longueur totale:
        <select id="lengthSelect">
          <option value="8">8 caract√®res</option>
          <option value="12">12 caract√®res</option>
          <option value="16" selected>16 caract√®res</option>
          <option value="20">20 caract√®res</option>
          <option value="24">24 caract√®res</option>
          <option value="30">30 caract√®res</option>
          <option value="40">40 caract√®res</option>
          <option value="50">50 caract√®res</option>
        </select>
      </label>
      
      <div class="char-option">
        <label><input type="checkbox" id="includeLower" checked> Minuscules (a-z)</label>
        <div class="min-input-group">
            <label for="minLower">Min:</label>
            <input type="number" id="minLower" value="3" min="0" max="50">
        </div>
      </div>
      <div class="char-option">
        <label><input type="checkbox" id="includeUpper" checked> Majuscules (A-Z)</label>
        <div class="min-input-group">
            <label for="minUpper">Min:</label>
            <input type="number" id="minUpper" value="3" min="0" max="50">
        </div>
      </div>
      <div class="char-option">
        <label><input type="checkbox" id="includeDigits" checked> Chiffres (0-9)</label>
        <div class="min-input-group">
            <label for="minDigits">Min:</label>
            <input type="number" id="minDigits" value="3" min="0" max="50">
        </div>
      </div>
      <div class="char-option">
        <label><input type="checkbox" id="includeSpecial" checked> Caract√®res sp√©ciaux (%$!@#^&*) </label>
        <div class="min-input-group">
            <label for="minSpecial">Min:</label>
            <input type="number" id="minSpecial" value="5" min="0" max="50">
        </div>
      </div>

      <!-- NOUVELLE OPTION -->
      <label>
        <input type="checkbox" id="avoidConsecutive" checked>
        Interdire deux caract√®res identiques √† la suite
      </label>

      <button id="generateBtn">G√©n√©rer</button>
      <div id="errorMessage" class="error-message"></div> 
      <div class="password-output-group">
        <input type="text" id="passwordOutput" readonly placeholder="Votre mot de passe">
        <button id="toggleVisibilityBtn" title="Afficher/Masquer le mot de passe">üôà</button> 
      </div>
      <button id="copyBtn">Copier&nbsp;üìã</button>
      
      <div id="strengthDisplay" class="strength">
        <div class="strength-bar">
          <div id="strengthIndicator" class="strength-indicator"></div>
        </div>
        <div id="strengthText" class="strength-text">Robustesse : Non √©valu√©e</div>
      </div>
    </div>
  </div>

  <script>
    // √âl√©ments du DOM (centralis√©s)
    const DOMElements = {
        lengthSelect:           document.getElementById('lengthSelect'),
        includeLower:           document.getElementById('includeLower'),
        minLower:               document.getElementById('minLower'),
        includeUpper:           document.getElementById('includeUpper'),
        minUpper:               document.getElementById('minUpper'),
        includeDigits:          document.getElementById('includeDigits'),
        minDigits:              document.getElementById('minDigits'),
        includeSpecial:         document.getElementById('includeSpecial'),
        minSpecial:             document.getElementById('minSpecial'),
        generateBtn:            document.getElementById('generateBtn'),
        passwordOutput:         document.getElementById('passwordOutput'),
        toggleVisibilityBtn:    document.getElementById('toggleVisibilityBtn'),
        copyBtn:                document.getElementById('copyBtn'),
        strengthText:           document.getElementById('strengthText'),
        strengthIndicator:      document.getElementById('strengthIndicator'),
        strengthDisplay:        document.getElementById('strengthDisplay'),
        themeToggle:            document.getElementById('themeToggle'),
        body:                   document.body,
        errorMessage:           document.getElementById('errorMessage'),
        avoidConsecutive:       document.getElementById('avoidConsecutive')
    };

    // Jeu de caract√®res de base
    const BASE_CHAR_SETS = {
      lower:   'abcdefghijklmnopqrstuvwxyz',
      upper:   'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
      digits:  '0123456789',
      special: '%$!@#^&*' 
    };

    // Utils RNG
    function randIndex(maxExclusive) {
      return crypto.getRandomValues(new Uint32Array(1))[0] % maxExclusive;
    }

    function getRandomCharFromSet(setStr, excludeSet = new Set()) {
      if (!setStr || setStr.length === 0) return '';
      // Essais al√©atoires d'abord
      for (let tries = 0; tries < 32; tries++) {
        const c = setStr.charAt(randIndex(setStr.length));
        if (!excludeSet.has(c)) return c;
      }
      // Fallback d√©terministe
      for (let i = 0; i < setStr.length; i++) {
        const c = setStr.charAt(i);
        if (!excludeSet.has(c)) return c;
      }
      return ''; // impossible si setStr a >= 1 char non exclu
    }

    function charTypeOf(ch) {
      if (BASE_CHAR_SETS.lower.includes(ch)) return 'lower';
      if (BASE_CHAR_SETS.upper.includes(ch)) return 'upper';
      if (BASE_CHAR_SETS.digits.includes(ch)) return 'digits';
      if (BASE_CHAR_SETS.special.includes(ch)) return 'special';
      return null;
    }

    function countTypes(arr) {
      const map = { lower: 0, upper: 0, digits: 0, special: 0 };
      for (const c of arr) {
        const t = charTypeOf(c);
        if (t) map[t]++;
      }
      return map;
    }

    /**
     * Corrige un tableau de caract√®res pour supprimer tout doublon cons√©cutif,
     * en respectant les min par type.
     */
    function enforceNoConsecutiveDuplicates(pwdArray, allCharsPool, minMap) {
      const out = pwdArray.slice();
      const counts = countTypes(out);

      // S√©curit√©: si le pool n'a qu'un seul caract√®re, impossible d'√©viter les doublons cons√©cutifs
      const uniquePool = Array.from(new Set(allCharsPool.split('')));
      if (uniquePool.length <= 1 && out.length > 1) {
        DOMElements.errorMessage.textContent = 'Impossible d‚Äô√©viter les doublons cons√©cutifs avec un pool d‚Äôun seul caract√®re.';
        return out;
      }

      for (let i = 1; i < out.length; i++) {
        if (out[i] === out[i - 1]) {
          const original = out[i];
          const originalType = charTypeOf(original);
          const exclude = new Set([out[i - 1]]);
          if (i + 1 < out.length) exclude.add(out[i + 1]); // √©viter de cr√©er un nouveau doublon

          let replacement = '';
          // Si on est au minimum pour ce type, on doit remplacer par le m√™me type
          if (originalType && counts[originalType] <= (minMap[originalType] || 0)) {
            replacement = getRandomCharFromSet(BASE_CHAR_SETS[originalType], exclude);
            if (!replacement) {
              // en dernier recours, choisir autre chose qui ne casse pas un autre min
              replacement = getRandomCharFromSet(allCharsPool, exclude);
              const newType = charTypeOf(replacement);
              if (newType && newType !== originalType) {
                // garder les compteurs coh√©rents
                counts[originalType] = Math.max(0, counts[originalType] - 1);
                counts[newType] = (counts[newType] || 0) + 1;
              }
            }
          } else {
            // Libre de changer de type si √ßa ne fait pas descendre en dessous du min
            replacement = getRandomCharFromSet(allCharsPool, exclude);
            const newType = charTypeOf(replacement);
            if (originalType && newType && newType !== originalType) {
              counts[originalType] = Math.max(0, counts[originalType] - 1);
              counts[newType] = (counts[newType] || 0) + 1;
            }
          }

          // S√©curit√© finale si replacement vide (tr√®s improbable)
          if (!replacement) {
            // choisir un char diff√©rent du pr√©c√©dent dans le pool unique
            replacement = uniquePool.find(c => c !== out[i - 1]) || out[i];
          }

          out[i] = replacement;
        }
      }
      return out;
    }

    /**
     * G√©n√®re un mot de passe s√©curis√©.
     * Garantie : au moins le nombre sp√©cifi√© de chaque type s√©lectionn√©.
     * Tente de g√©n√©rer un mot de passe "Tr√®s fort" par d√©faut.
     */
    function generatePassword() {
      DOMElements.errorMessage.textContent = ''; // Effacer le message d'erreur pr√©c√©dent

      const length = parseInt(DOMElements.lengthSelect.value);
      const avoidConsecutive = DOMElements.avoidConsecutive.checked;

      let characterRequirements = [];
      let totalGuaranteedCount = 0;
      let allCharsPool = ''; // Pool de tous les caract√®res possibles pour les caract√®res restants

      // Collecter les exigences de caract√®res et calculer le total garanti
      if (DOMElements.includeLower.checked) {
        const count = parseInt(DOMElements.minLower.value) || 0;
        characterRequirements.push({ type: 'lower', chars: BASE_CHAR_SETS.lower, minCount: count });
        totalGuaranteedCount += count;
        allCharsPool += BASE_CHAR_SETS.lower;
      }
      if (DOMElements.includeUpper.checked) {
        const count = parseInt(DOMElements.minUpper.value) || 0;
        characterRequirements.push({ type: 'upper', chars: BASE_CHAR_SETS.upper, minCount: count });
        totalGuaranteedCount += count;
        allCharsPool += BASE_CHAR_SETS.upper;
      }
      if (DOMElements.includeDigits.checked) {
        const count = parseInt(DOMElements.minDigits.value) || 0;
        characterRequirements.push({ type: 'digits', chars: BASE_CHAR_SETS.digits, minCount: count });
        totalGuaranteedCount += count;
        allCharsPool += BASE_CHAR_SETS.digits;
      }
      if (DOMElements.includeSpecial.checked) {
        const count = parseInt(DOMElements.minSpecial.value) || 0;
        characterRequirements.push({ type: 'special', chars: BASE_CHAR_SETS.special, minCount: count });
        totalGuaranteedCount += count;
        allCharsPool += BASE_CHAR_SETS.special;
      }

      if (characterRequirements.length === 0) {
        DOMElements.errorMessage.textContent = 'Veuillez s√©lectionner au moins un type de caract√®res.';
        return '';
      }

      if (totalGuaranteedCount > length) {
        DOMElements.errorMessage.textContent = `Le nombre minimum de caract√®res requis (${totalGuaranteedCount}) d√©passe la longueur totale (${length}). Veuillez ajuster.`;
        return '';
      }

      // Assurez-vous que le pool n'est pas vide si la longueur totale est > 0
      if (allCharsPool.length === 0 && length > 0) {
        DOMElements.errorMessage.textContent = 'Aucun type de caract√®re n\'a √©t√© s√©lectionn√© pour g√©n√©rer le mot de passe.';
        return '';
      }

      let pwdArray = [];

      // 1) Garantir le minimum de chaque type s√©lectionn√©
      characterRequirements.forEach(req => {
        for (let i = 0; i < req.minCount; i++) {
          let c = req.chars.charAt(randIndex(req.chars.length));
          if (DOMElements.avoidConsecutive.checked && pwdArray.length > 0) {
            const exclude = new Set([pwdArray[pwdArray.length - 1]]);
            // √©viter un doublon lors du push du garanti
            c = getRandomCharFromSet(req.chars, exclude);
          }
          pwdArray.push(c);
        }
      });
      
      // 2) Remplir le reste du mot de passe jusqu'√† la longueur souhait√©e
      const remainingLength = length - pwdArray.length;
      for (let i = 0; i < remainingLength; i++) {
        let c = allCharsPool.charAt(randIndex(allCharsPool.length));
        if (DOMElements.avoidConsecutive.checked && pwdArray.length > 0) {
          const exclude = new Set([pwdArray[pwdArray.length - 1]]);
          c = getRandomCharFromSet(allCharsPool, exclude);
        }
        pwdArray.push(c);
      }

      // 3) M√©langer
      const shuffled = shuffleArray(pwdArray);

      // 4) Si demand√©, corriger les doublons cons√©cutifs apr√®s m√©lange
      if (avoidConsecutive) {
        // Construire la map des min par type
        const minMap = { lower: 0, upper: 0, digits: 0, special: 0 };
        characterRequirements.forEach(r => { minMap[r.type] = r.minCount; });
        const fixed = enforceNoConsecutiveDuplicates(shuffled, allCharsPool, minMap);
        return fixed.join('');
      }

      return shuffled.join('');
    }

    /**
     * M√©lange un tableau (algorithme de Fisher‚ÄìYates).
     */
    function shuffleArray(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = randIndex(i + 1);
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    /**
     * √âvalue la force du mot de passe selon longueur et diversit√©.
     * Score plus pr√©cis bas√© sur le nombre de chaque type.
     */
    function evaluateStrength(pwd) {
      if (!pwd) {
        return { text: 'Non √©valu√©e', score: 0 };
      }

      let score = 0;
      const length = pwd.length;

      // Score de longueur (logarithmique pour mieux repr√©senter la complexit√©)
      score += Math.log2(length) * 5; 

      // Compte des types de caract√®res et score de vari√©t√©
      let typesCount = 0;
      if (/[a-z]/.test(pwd)) typesCount++;
      if (/[A-Z]/.test(pwd)) typesCount++;
      if (/[0-9]/.test(pwd)) typesCount++;
      if (/[%\$!@#\^&\*]/.test(pwd)) typesCount++; // Correspond au BASE_CHAR_SETS.special
      
      score += typesCount * 10;

      // Score bas√© sur le nombre de chaque type de caract√®re
      score += (pwd.match(/[a-z]/g) || []).length * 0.5;
      score += (pwd.match(/[A-Z]/g) || []).length * 0.7;
      score += (pwd.match(/[0-9]/g) || []).length * 0.6;
      score += (pwd.match(/[%\$!@#\^&\*]/g) || []).length * 0.8;

      const maxScore = 100; 
      score = Math.max(0, Math.min(score, maxScore));

      let strengthText = '';
      let strengthLevel = score / maxScore;

      if (strengthLevel < 0.25) {
        strengthText = 'Faible';
        DOMElements.strengthIndicator.style.backgroundColor = 'var(--strength-weak)';
      } else if (strengthLevel < 0.5) {
        strengthText = 'Moyen';
        DOMElements.strengthIndicator.style.backgroundColor = 'var(--strength-medium)';
      } else if (strengthLevel < 0.75) {
        strengthText = 'Fort';
        DOMElements.strengthIndicator.style.backgroundColor = 'var(--strength-strong)';
      } else {
        strengthText = 'Tr√®s fort';
        DOMElements.strengthIndicator.style.backgroundColor = 'var(--strength-very-strong)';
      }

      DOMElements.strengthIndicator.style.width = `${strengthLevel * 100}%`;
      return { text: strengthText, score: strengthLevel };
    }

    // Fonction pour mettre √† jour la robustesse affich√©e
    function updateStrengthDisplay(pwd = DOMElements.passwordOutput.value) {
        const { text } = evaluateStrength(pwd);
        DOMElements.strengthText.textContent = `Robustesse : ${text}`;
    }

    // Fonction pour ajuster dynamiquement la valeur max des inputs num√©riques
    function adjustMinMaxLimits() {
        const totalLength = parseInt(DOMElements.lengthSelect.value);
        let currentMins = 0;

        const charTypes = ['lower', 'upper', 'digits', 'special'];
        let charMins = {};

        // R√©cup√©rer les valeurs actuelles des minimums pour les types coch√©s
        charTypes.forEach(type => {
            const checkbox = DOMElements[`include${type.charAt(0).toUpperCase() + type.slice(1)}`];
            const minInput = DOMElements[`min${type.charAt(0).toUpperCase() + type.slice(1)}`];
            charMins[type] = parseInt(minInput.value) || 0;
            if (checkbox.checked) {
                currentMins += charMins[type];
            }
        });

        // Mettre √† jour le 'max' pour chaque champ 'min'
        charTypes.forEach(type => {
            const minInput = DOMElements[`min${type.charAt(0).toUpperCase() + type.slice(1)}`];
            const checkbox = DOMElements[`include${type.charAt(0).toUpperCase() + type.slice(1)}`];
            const otherMins = currentMins - charMins[type];
            let newMax = checkbox.checked ? Math.max(0, totalLength - otherMins) : 0;
            minInput.max = newMax;
            if (parseInt(minInput.value) > newMax) {
                minInput.value = newMax;
            }
        });
    }

    // Gestionnaires d'√©v√©nements
    DOMElements.generateBtn.addEventListener('click', () => {
      const pwd = generatePassword();
      DOMElements.passwordOutput.value = pwd;
      DOMElements.toggleVisibilityBtn.textContent = 'üôà';
      updateStrengthDisplay(pwd);
      DOMElements.passwordOutput.focus(); 
    });

    DOMElements.copyBtn.addEventListener('click', () => {
      const pwd = DOMElements.passwordOutput.value;
      if (!pwd) return;
      navigator.clipboard.writeText(pwd)
        .then(() => { 
            DOMElements.copyBtn.textContent = 'Copi√© !'; 
            setTimeout(() => DOMElements.copyBtn.textContent = 'Copier üìã', 1500); 
        })
        .catch(() => { 
            DOMElements.errorMessage.textContent = '√âchec de la copie. Veuillez copier manuellement.';
            setTimeout(() => DOMElements.errorMessage.textContent = '', 3000); 
        });
    });

    DOMElements.toggleVisibilityBtn.addEventListener('click', () => {
        if (DOMElements.passwordOutput.type === 'password') {
            DOMElements.passwordOutput.type = 'text';
            DOMElements.toggleVisibilityBtn.textContent = 'üôà';
        } else {
            DOMElements.passwordOutput.type = 'password';
            DOMElements.toggleVisibilityBtn.textContent = 'üëÅÔ∏è';
        }
    });

    DOMElements.themeToggle.addEventListener('click', () => {
      DOMElements.body.classList.toggle('dark');
      DOMElements.themeToggle.textContent = DOMElements.body.classList.contains('dark') ? 'Mode clair' : 'Mode sombre';
    });

    // Reg√©n√©rer quand l'option anti-doublon change
    DOMElements.avoidConsecutive.addEventListener('change', () => {
      adjustMinMaxLimits();
      updateStrengthDisplay();
      DOMElements.generateBtn.click();
    });

    // √âcouteurs pour les options de caract√®res et les minimums
    const charOptionInputs = [
      { checkbox: DOMElements.includeLower, number: DOMElements.minLower },
      { checkbox: DOMElements.includeUpper, number: DOMElements.minUpper },
      { checkbox: DOMElements.includeDigits, number: DOMElements.minDigits },
      { checkbox: DOMElements.includeSpecial, number: DOMElements.minSpecial }
    ];

    charOptionInputs.forEach(item => {
      item.number.disabled = !item.checkbox.checked; 
      
      item.checkbox.addEventListener('change', () => {
        item.number.disabled = !item.checkbox.checked;
        if (!item.checkbox.checked) {
          item.number.value = '0';
        } else {
            if (parseInt(item.number.value) === 0 || item.number.value === '') {
                item.number.value = '1';
            }
        }
        adjustMinMaxLimits(); 
        updateStrengthDisplay(); 
        DOMElements.generateBtn.click();
      });

      item.number.addEventListener('input', () => {
          if (parseInt(item.number.value) === 0) {
              item.checkbox.checked = false;
              item.number.disabled = true;
          } else {
              item.checkbox.checked = true;
              item.number.disabled = false;
          }
          adjustMinMaxLimits(); 
          updateStrengthDisplay(); 
          DOMElements.generateBtn.click();
      });
    });
    
    // √âcouteurs pour la mise √† jour de la robustesse et des limites lors des changements de longueur
    DOMElements.lengthSelect.addEventListener('change', () => {
        adjustMinMaxLimits();
        updateStrengthDisplay();
        DOMElements.generateBtn.click();
    });

    // G√©n√©rer un mot de passe au chargement et initialiser
    window.addEventListener('load', () => {
        charOptionInputs.forEach(item => {
            item.number.disabled = !item.checkbox.checked;
        });

        DOMElements.includeLower.checked = true;
        DOMElements.includeUpper.checked = true;
        DOMElements.includeDigits.checked = true;
        DOMElements.includeSpecial.checked = true;
        DOMElements.minLower.value = '3';
        DOMElements.minUpper.value = '3';
        DOMElements.minDigits.value = '3';
        DOMElements.minSpecial.value = '5';

        DOMElements.lengthSelect.value = '20'; 

        DOMElements.passwordOutput.type = 'text'; 
        DOMElements.toggleVisibilityBtn.textContent = 'üôà';
        
        adjustMinMaxLimits();
        DOMElements.generateBtn.click();
    });
  </script>
</body>
</html>
